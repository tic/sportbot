import {
  Client,
  ClientOptions,
  Intents,
  Message,
  MessageEmbed,
  MessageOptions,
  MessagePayload,
  TextChannel,
} from 'discord.js';
import {
  Semaphore,
  sleep,
} from './util.service';
import { config, GenericSourceType } from '../config';
import { logError, logMessage } from './logger.service';
import { ChannelClassEnum } from '../types/serviceDiscordTypes';
import { LogCategoriesEnum } from '../types/serviceLoggerTypes';

const throttleSleepTimeMs = config.meta.inDevelopment ? 5000 : 60000;

const options: ClientOptions = {
  intents: new Intents()
    .add(Intents.FLAGS.DIRECT_MESSAGES)
    .add(Intents.FLAGS.GUILDS)
    .add(Intents.FLAGS.GUILD_MESSAGES)
    .add(Intents.FLAGS.GUILD_MESSAGE_REACTIONS),
};
const client = new Client(options);

const messageQueue: MessagePayload[] = [];
const queueLock = new Semaphore(1);
const throttleMessages = async () => {
  // eslint-disable-next-line no-constant-condition
  while (true) {
    let didSomething = false;
    while (messageQueue.length > 0) {
      didSomething = true;
      logMessage(config.discord.identifier, 'draining message queue');
      // eslint-disable-next-line no-await-in-loop
      const release = await queueLock.acquire();
      const messagePayload = messageQueue.shift() as MessagePayload;
      (messagePayload.target as TextChannel).send(messagePayload);
      release();
      // eslint-disable-next-line no-await-in-loop
      await sleep(3000);
    }
    if (didSomething) {
      logMessage(config.discord.identifier, 'message queue emptied');
    }
    // eslint-disable-next-line no-await-in-loop
    await sleep(throttleSleepTimeMs);
  }
};

const messageHandler = async (message: Message) => {
  if (!message.content.startsWith(config.discord.prefix)) {
    return;
  }

  const argv = message.content.split(' ');

  logMessage(
    config.discord.identifier,
    `user ${message.author.username}#${message.author.discriminator}[${message.author.id}] issued command '${argv[0]}'`,
  );

  if (argv[0] === `${config.discord.prefix}help`) {
    const embed = new MessageEmbed()
      .setTitle('EventBot Help')
      .setDescription('Here is a list of commands I know how to respond to!')
      .setColor('RANDOM')
      .setFooter({ text: `This message was automatically generated by ${config.discord.username}` })
      .addFields([
        { name: 'watching', value: 'Get a list of events I watch for.' },
        { name: 'help', value: 'Show this message.' },
      ])
      .setTimestamp();

    message.reply({ embeds: [embed] });
  } else if (argv[0] === `${config.discord.prefix}watching`) {
    const embedFields = Object.values(config.source).map((source: GenericSourceType) => {
      let details = 'All';
      if (source.followedTeams?.length === 1) {
        [details] = source.followedTeams;
      } else if (source.followedTeams?.length === 2) {
        details = source.followedTeams.join(' and ');
      } else if (source.followedTeams?.length > 2) {
        details = `${source.followedTeams.slice(0, -1).join(', ')}, and ${source.followedTeams.slice(-1)[0]}`;
      }

      return { name: source.friendlyName, value: details, inline: true };
    });

    const embed = new MessageEmbed()
      .setTitle('EventBot Watch List')
      .setDescription(`I currently post about events from ${Object.keys(config.source).length} different sources:`)
      .setColor('RANDOM')
      .setFooter({ text: `This message was automatically generated by ${config.discord.username}` })
      .addFields(embedFields)
      .setTimestamp();

    message.reply({ embeds: [embed] });
  }
};

export const initialize = () => new Promise((resolve) => {
  client.login(config.discord.secret);
  client.on('ready', () => {
    logMessage(config.discord.identifier, `${config.discord.username} has logged in.`);
    resolve(true);
    throttleMessages();
  });
  client.on('error', (error) => {
    logError(LogCategoriesEnum.ANNOUNCE_FAILURE, config.discord.identifier, String(error));
  });
  client.on('messageCreate', messageHandler);
});

export const announce = async (
  channelClass: ChannelClassEnum,
  message?: string,
  embed?: MessageEmbed,
  taggedRoles: string[] = [],
) : Promise<boolean> => {
  if (message === undefined && embed === undefined) {
    return false;
  }
  const release = await queueLock.acquire();
  config.discord.servers.forEach((server) => {
    const destinationChannels = server.channels[channelClass];
    if (!destinationChannels || destinationChannels.length === 0) {
      return;
    }
    embed.setFooter({
      text: `This message was automatically generated by ${config.discord.username}`,
    }).setTimestamp();
    const messageOptions = {
      embeds: [embed],
    } as MessageOptions;
    if (taggedRoles.length > 0 || message) {
      const roleContent = taggedRoles.map((roleName) => {
        const roleId = server.roles.find((role) => role.name === roleName)?.id;
        return roleId ? `<@&${roleId}>` : '';
      }).join(' ');
      messageOptions.content = roleContent + (message || '');
    }
    destinationChannels.forEach((rawChannel) => {
      const channel = client.channels.cache.get(rawChannel.id);
      if (channel && channel.isText()) {
        messageQueue.push(new MessagePayload(
          channel,
          messageOptions,
        ));
      }
    });
  });
  release();
  return true;
};
